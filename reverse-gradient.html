<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reverse Gradient</title>
</head>

<body>
    <canvas id="cvs1" width="100" height="200"></canvas>
    <canvas id="cvs2" width="100" height="200"></canvas>
    <br><br><br>
    <canvas id="cvs3" width="100" height="200"></canvas>
    <canvas id="cvs4" width="100" height="200"></canvas>
    <br><br><br>
    <canvas id="cvs5" width="100" height="200"></canvas>
    <canvas id="cvs6" width="100" height="200"></canvas>

    <script>
        /////////////////////////////////////////////////////////////////////////////////////////
        const holeValue = 0;

        function buildTrace(numPoints) {
            const trace = {
                x0: 0,
                x1: 25,
                y: [],
                z: [],
            };

            for (let i = 0; i < numPoints; i++) {
                trace.y.push(i);
                let val = Math.round(Math.random() * 9) + 1;
                if (Math.random() < 0.3) { // 30 % holes
                    val = holeValue;
                }
                trace.z.push(val);
            }

            const x0 = trace.x0;
            const x1 = trace.x1;
            const y0 = Math.min(...trace.y);
            const y1 = Math.max(...trace.y);
            const ranges = {
                x: { min: x0, max: x1 },
                y: { min: y0, max: y1 },
                z: { min: -0.1, max: 1.1 },
            };

            return { trace, y0, y1, ranges };
        }

        /////////////////////////////////////////////////////////////////////////////////////////
        function setGradientColors(trace, ranges, gradient, y0, y1) {
            console.log('y0, y1:', y0, y1);
            let previous;

            for (let i = 0; i < trace.y.length; i++) {
                let z = trace.z[i];
                const hole = z === holeValue;

                if (z < ranges.z.min) {
                    z = ranges.z.min;
                }

                if (z > ranges.z.max) {
                    z = ranges.z.max;
                }

                const offset = (trace.y[i] - y0) / (y1 - y0);
                const holeOffset = previous ? previous.offset + ((offset - previous.offset) / 2) : 0;

                console.log('offset, hole offset:', offset, holeOffset);

                let color;
                let indices = [];

                if (hole) {
                    color = 'rgba(0,0,0,0)';

                    if (previous) {
                        gradient.addColorStop(holeOffset, previous.color);
                        gradient.addColorStop(holeOffset, color);
                    }
                } else {
                    color = 'blue';
                    indices = [0];

                    if (previous && JSON.stringify(indices) !== JSON.stringify(previous.indices)) {
                        gradient.addColorStop(offset, previous.color);
                    } else if (previous && previous.holeValue) {
                        gradient.addColorStop(holeOffset, 'rgba(0,0,0,0)');
                        gradient.addColorStop(holeOffset, color);
                    }
                }

                gradient.addColorStop(offset, color);
                previous = { offset, holeValue, color, indices };
            }
        }

        function drawTrace(trace, y0, y1, ranges, cvs, reverseX, reverseY) {
            const ctx = cvs.getContext('2d');
            const scaleX = cvs.width / (ranges.x.max - ranges.x.min);
            const scaleY = cvs.height / (ranges.y.max - ranges.y.min);

            console.log('width, height:', cvs.width, cvs.height);

            let x = Math.ceil(
                reverseX ? cvs.width - ((trace.x1 - ranges.x.min) * scaleX) : (trace.x0 - ranges.x.min) * scaleX
            );
            let w = Math.ceil(
                (trace.x1 - trace.x0) * scaleX
            );
            let y = Math.ceil(
                reverseY ? (y0 - ranges.y.min) * scaleY : cvs.height - ((y1 - ranges.y.min) * scaleY)
            );
            let h = Math.ceil(
                (y1 - y0) * scaleY
            );

            if (w > 0 && h > 0) {
                console.log('x, y, w, h:', x, y, w, h);
                const gradient = ctx.createLinearGradient(x, y + h, x, y);
                setGradientColors(
                    trace,
                    ranges,
                    gradient,
                    reverseY ? y1 : y0,
                    reverseY ? y0 : y1,
                );

                ctx.beginPath();
                ctx.fillStyle = gradient;

                x = Math.max(x, 0);
                w = Math.min(w, cvs.width);
                y = Math.max(y, 0);
                h = Math.min(h, cvs.height);

                ctx.fillRect(x, y, w, h);
            } else {
                console.error('!!! not draw');
            }
        }

        /////////////////////////////////////////////////////////////////////////////////////////
        {
            const { trace, y0, y1, ranges } = buildTrace(30);
            drawTrace(trace, y0, y1, ranges, document.getElementById('cvs1'));
            // Expect to flip
            drawTrace(trace, y0, y1, ranges, document.getElementById('cvs2'), false, true);
        }
        {
            const { trace, y0, y1, ranges } = buildTrace(50);
            drawTrace(trace, y0, y1, ranges, document.getElementById('cvs3'));
            // Expect to flip
            drawTrace(trace, y0, y1, ranges, document.getElementById('cvs4'), false, true);
        }
        {
            const { trace, y0, y1, ranges } = buildTrace(80);
            drawTrace(trace, y0, y1, ranges, document.getElementById('cvs5'));
            trace.z.reverse();
            // Expect to be the same
            drawTrace(trace, y0, y1, ranges, document.getElementById('cvs6'), false, true);
        }

        /////////////////////////////////////////////////////////////////////////////////////////
    </script>
</body>

</html>
